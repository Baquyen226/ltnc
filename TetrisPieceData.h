#pragma once
#pragma once
#ifndef TETRISPIECE_H
#define TETRISPIECE_H
#endif

enum PieceType {
	I_PIECE = 0,
	L_PIECE,
	J_PIECE,
	S_PIECE,
	Z_PIECE,
	T_PIECE,
	O_PIECE,
	BAG_SIZE
};


const int Piece_Shape[7 /*No of pieces*/][4 /*No of rotations*/][4][4] = {
	//I piece (piece 1, please read enum later lol)
	{
		//Rotation 0
		{
			{0,0,0,0},
			{1,1,1,1},
			{0,0,0,0},
			{0,0,0,0}
		},
	//Rotation 1
	{
		{0,1,0,0},
		{0,1,0,0},
		{0,1,0,0},
		{0,1,0,0}
	},
	//Rotation 2
	{
		{0,0,0,0},
		{0,0,0,0},
		{1,1,1,1},
		{0,0,0,0}
	},
	//Rotation 3
	{
		{0,0,1,0},
		{0,0,1,0},
		{0,0,1,0},
		{0,0,1,0}
	}
},

//L piece (Piece 2)
{
	//Rotation 0
	{
		{0,0,0,0},
		{2,0,0,0},
		{2,2,2,0},
		{0,0,0,0}
	},
	//Rotation 1
	{
		{0,2,2,0},
		{0,2,0,0},
		{0,2,0,0},
		{0,0,0,0}
	},
	//Rotation 2
	{
		{0,0,0,0},
		{2,2,2,0},
		{0,0,2,0},
		{0,0,0,0}
	},
	//Rotation 3
	{
		{0,2,0,0},
		{0,2,0,0},
		{2,2,0,0},
		{0,0,0,0}
	}
},

//J piece (Piece 2)
{
	//Rotation 0
	{
		{0,0,0,0},
		{0,0,3,0},
		{3,3,3,0},
		{0,0,0,0}
	},
	//Rotation 1
	{
		{0,3,0,0},
		{0,3,0,0},
		{0,3,3,0},
		{0,0,0,0}
	},
	//Rotation 2
	{
		{0,0,0,0},
		{3,3,3,0},
		{3,0,0,0},
		{0,0,0,0}
	},
	//Rotation 3
	{
		{3,3,0,0},
		{0,3,0,0},
		{0,3,0,0},
		{0,0,0,0}
	},
},

//S piece (Piece 3)
{
	//Rotation 0
	{
		{4,4,0,0},
		{0,4,4,0},
		{0,0,0,0},
		{0,0,0,0}
	},
	//Rotation 1
	{
		{0,0,4,0},
		{0,4,4,0},
		{0,4,0,0},
		{0,0,0,0}
	},
	//Rotation 2
	{
		{0,0,0,0},
		{4,4,0,0},
		{0,4,4,0},
		{0,0,0,0}
	},
	//Rotation 3
	{
		{0,4,0,0},
		{4,4,0,0},
		{4,0,0,0},
		{0,0,0,0}
	}
},

//Z piece (Piece 4)
{
	//Rotation 0
	{
		{0,5,5,0},
		{5,5,0,0},
		{0,0,0,0},
		{0,0,0,0}
	},
	//Rotation 1
	{
		{0,5,0,0},
		{0,5,5,0},
		{0,0,5,0},
		{0,0,0,0}
	},
	//Rotation 2
	{
		{0,0,0,0},
		{0,5,5,0},
		{5,5,0,0},
		{0,0,0,0}
	},
	//Rotation 3
	{
		{5,0,0,0},
		{5,5,0,0},
		{0,5,0,0},
		{0,0,0,0}
	}
},

//T piece (Piece 5)
{
	//Rotation 0
	{
		{0,6,0,0},
		{6,6,6,0},
		{0,0,0,0},
		{0,0,0,0}
	},
	//Rotation 1
	{
		{0,6,0,0},
		{0,6,6,0},
		{0,6,0,0},
		{0,0,0,0}
	},
	//Rotation 2
	{
		{0,0,0,0},
		{6,6,6,0},
		{0,6,0,0},
		{0,0,0,0}
	},
	//Rotation 3
	{
		{0,6,0,0},
		{6,6,0,0},
		{0,6,0,0},
		{0,0,0,0}
	}
},

//O piece :oyes:
{
	//Rotate!! Copy paste !!
	{
		{0,0,0,0},
		{0,7,7,0},
		{0,7,7,0},
		{0,0,0,0}
	},
	//2
	{
		{0,0,0,0},
		{0,7,7,0},
		{0,7,7,0},
		{0,0,0,0}
	},
	//3
	{
		{0,0,0,0},
		{0,7,7,0},
		{0,7,7,0},
		{0,0,0,0}
	},

	//4
	{
		{0,0,0,0},
		{0,7,7,0},
		{0,7,7,0},
		{0,0,0,0}
	}
}
};

//Wall kick data(reference: https://tetris.fandom.com/wiki/SRS)

const int defaultOffsetData[4][5][2] = {
	//rotation 0 -> 1
   {{0, 0}, {-1, 0}, {-1, 1}, {0, -2}, {-1, -2}},

   //rotation 1 -> 2
  {{0, 0}, {1, 0}, {1, -1}, {0, 2}, {1, 2}},

  //rotation 2 -> 3
 {{0, 0}, {1, 0}, {1, 1}, {0, -2}, {1, -2}},

 //rotation 3 -> 0
 {{0, 0}, {-1, 0}, {-1, -1}, {0, 2}, {-1, 2}}
};

const int I_Piece_offsetData[4][5][2] = {
	//rotation 0
	{{0, 0}, {-2, 0}, {1, 0}, {-2, -1}, {1, 2}},

	//rotation 1
	{{0, 0}, {-1, 0}, {2, 0}, {-1, 2}, {2, -1}},

	//rotation 2
	{{0, 0}, {2, 0}, {-1, 0}, {2, 1}, {-1, -2}},

	//rotation 3
	{{0, 0}, {1, 0}, {-2, 0}, {1, -2}, {-2, 1}}
};

